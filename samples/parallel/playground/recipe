#	Controlled by MAXJOBS variable.
#
#	If MAXJOBS is not defined parallel_depends_on() works as usual
#	depends-on. If MAXJOBS is defined then parallel_depends_on()
#	builds each target in seperate process. In this mode stdout
#	and stderr are scattered. If logging is requested logs are baked
#	together to be readable with stderr (-l 2) or both stdout and
#	stderr (-l 1 ... 2>&1). Due to shell redirection limitations
#	other log handlers can not be used in MAXJOBS=y mode.

parallel_depends_on ()
{
	if test -z "$MAXJOBS"		# jobs are controlled externally
	then
		depends-on $*
	else
		if test -z "$REDO_LOG_FD"	# no log
		then
			for DEP in $*
			do
				redo $DEP &
			done
			wait
			depends-on $*

		elif test "$REDO_LOG_FD" = 2
		then
			LOGS=

			for DEP in $*
			do
				LOG=$(mktemp /tmp/redoXXXXXXXX)
				LOGS="$LOGS $LOG"
				redo -l 2 $DEP 2>$LOG &
			done

			wait

			cat $LOGS >&2
			rm -f $LOGS

			depends-on $*

		elif test "$REDO_LOG_FD" = 1
		then
			LOGS=

			for DEP in $*
			do
				LOG=$(mktemp /tmp/redoXXXXXXXX)
				LOGS="$LOGS $LOG"
				redo -l 1 $DEP >$LOG 2>&1 &
			done

			wait

			cat $LOGS
			rm -f $LOGS

			depends-on $* 2>&1
		else
			echo Bad log file descriptor
			exit 1
		fi
	fi
}

echo $1

parallel_depends_on $DEPS

lua -e 'local t = os.clock() + '$DELAY' repeat until os.clock() > t'
cat $DEPS > $3

echo $1 ok >&2

